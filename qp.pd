# template auto generated by pptemplate
# uncomment commands, copy and fill in as needed
# see also the PDL::PP manpage

# pp_bless('');       # package namespace of pp_def'ed functions
              # defaults to 'PDL'

# pp_add_boot('');    # code to add to the XS boot section

# pp_addhdr('');      # add C code to the section preceding 
              # the first MODULE keyword

# pp_addpm('');       # add perl code to the perl module that PP will create

# pp_add_exported(''); # add the list of function names
                       # to the list of exported functions 

# pp_addxs('');        # add plain XS code to the XS section

# pp_add_isa(qw//);    # inheritance business: add arglist to modules @ISA

# pp_def('name', Code => '');  # minimal pp_def to define function 




# TODO 
# check sample / return value from func
# Check (for lbfgs[b]) ref count
# Min/Majuscules
# Redo rmn example
# optimize without function parameter => pb

our $VERSION = 0.03;
use PDL::Exporter;

pp_setversion(0.03);

pp_addhdr('
pdl    *pdl1, *pdl2, *pdl3, *pdl4, *pdl5;
SV    *sv_pdl1, *sv_pdl2, *sv_pdl3, *sv_pdl4, *sv_pdl5;
#include <math.h>
#include <stdio.h>
#include <string.h>
/* Change names when fixing glibc-2.1 bug */
#ifdef MY_FIXY0
#define y0(a) fixy0(a)
extern double fixy0(double a);
#endif
#ifdef MY_FIXYN
#define yn(a,b) fixyn(a,b)
extern double fixyn(int a, double b);
#endif
');

## handle various cases of 'finite'
#
if ($^O =~ /MSWin/) {
# _finite in VC++ 4.0
pp_addhdr('
#define finite _finite
#include <float.h>
/* avoid annoying warnings */
typedef long int logical;
typedef long int integer;
typedef long int ftnlen;
#ifdef __cplusplus
typedef float (*paramf)(...);
typedef double (*paramd)(...);
typedef void (*paramv)(...);
#else
typedef float (*paramf)();
typedef double (*paramd)();
typedef void (*paramv)();
#endif
');
}
else{
pp_addhdr('
/* avoid annoying warnings */
typedef int logical;
typedef int integer;
typedef int ftnlen;
#ifdef __cplusplus
typedef float (*paramf)(...);
typedef double (*paramd)(...);
typedef void (*paramv)(...);
#else
typedef float (*paramf)();
typedef double (*paramd)();
typedef void (*paramv)();
#endif
')
}

# patch from Albert Chin
if ($^O =~ /hpux/) {
pp_addhdr('
#ifdef isfinite
#define finite isfinite
#endif
');
}


pp_addpm({At=>'Top'},<<'EOD');
use strict;
use PDL::Ufunc;
use PDL::Ops;
use PDL::NiceSlice;

{ 
  package PDL;
  use UNIVERSAL 'isa'; # need that later in info function
  use Carp;
}


=head1 NAME

PDL::Opt::QP - ....

=head1 SYNOPSIS

 use PDL::Opt::QP;
 ...

=head1 DESCRIPTION

Some routines can handle bounds, so:

    minimize     f(x)
       x
    subject to   low <= x <= up

=cut

EOD

     #  subroutine qpgen2( ->dmat, ->dvec, fddmat, n, <-sol, <-lagr, 
     #      <-crval, ->amat, ->bvec, fdamat, q, ->meq, <-iact, <-nact,
     #      <-iter, work, <->ierr)  
     #  integer n, i, j, l, l1, 
     # *     info, q, iact(*), iter(*), it1,
     # *     ierr, nact, iwzv, iwrv, iwrm, iwsv, iwuv, nvl,
     # *     r, fdamat, iwnbv, meq, fddmat
     #  double precision dmat(fddmat,*), dvec(*), lagr(*), sol(*), bvec(*)
     # $     ,work(*), temp, sum, t1, tt, gc, gs, crval,nu, amat(fdamat,*)
     # $     , vsmall, tmpa, tmpb

pp_def("qpgen2",
    HandleBad => 0,
    Pars => 'dmat(m,m); dvec(m); int fddmat(); int n();
        [o]sol(m); [o]lagr(q); [o]crval();
        amat(m,q); bvec(q); int fdamat(); int q(); int meq();
        int [o]iact(q); int [o]nact();
        int [o]iter(2); [t]work(z); int [io]ierr();
    ',
    OtherPars => "" ,
    GenericTypes => [D],
    Code =>'
        extern int qpgen2_(
            double *dmat, double *dvec, integer *fddmat, integer *n,

            double *sol, double *lagr, double *crval, double *amat,
            double *bvec, integer *fdamat, integer *q, integer *meq,
            integer *iact, integer *nact, integer *iter, double *work,
            integer *ierr
        );

        qpgen2_(
            $P(dmat),
            $P(dvec),
            $P(fddmat),   // &fddmat,
            $P(n),        // &n,
            $P(sol),
            $P(lagr),
            $P(crval),
            $P(amat),
            $P(bvec),
            $P(fdamat),   // &fdamat,
            $P(q),        // &q,
            $P(meq),
            $P(iact),
            $P(nact),
            $P(iter),
            $P(work),     // work,
            $P(ierr)
        );

        // for (i = 0; i < $SIZE(n); i++)
        //  $x(n=>i) = xtmp[i];
        // $maxit()=it;

        // free(work);
',
    Doc =>'

=for ref

This routine solves the optimization problem

           minimize f(x)
              x

    .......

');

pp_add_exported('', 'qp');
pp_addpm({At=>'Bot'},<<'EOD');

sub qp {
  my ($Dmat, $dvec, $Amat, $bvec, $meq) = @_;

  my $n = $Dmat->dim(1);
  my $q = $Amat->dim(0);

  if( ! defined $bvec ){
    $bvec = zeros($q);
  }

  die("Dmat is not square!")
    if $n != $Dmat->dim(0);
  die("Dmat and dvec are incompatible!")
    if $n != $dvec->nelem;
  die("Amat and dvec are incompatible!")
    if $n != $Amat->dim(1);
  die("Amat and bvec are incompatible!")
    if $q != $bvec->nelem;
  die("Value of meq is invalid!")
    if ($meq > $q) || ($meq < 0 );

  my $iact = zeros($q);
  my $nact = pdl(0);
  my $r    = $n < $q ? $n : $q;
  my $sol  = zeros($n);
  my $lagr = zeros($q);
  my $crval= pdl(0);
  my $work = zeros(2*$n+$r*($r+5)/2+2*$q+1);
  my $iter = zeros(2);
  my $ierr = pdl(0);   # doubles as factorized

  my $res = qpgen2(
                   $Dmat, $dvec,
                   $n, $n,
                   $sol, $lagr,
                   $crval,
                   $Amat, $bvec, $n,
                   $q, $meq,
                   $iact, $nact,
                   $iter, $work,
                   $ierr
        );

  warn "### res = $res ###\n";

  # if( res1$ierr == 1)
  #   stop("constraints are inconsistent, no solution!")
  # else if( res1$ierr == 2)
  #   stop("matrix D in quadratic function is not positive definite!")
  #
  # list(solution=res1$sol,
  #      value=res1$crval,
  #      unconstrained.solution=res1$dvec,
  #      iterations=res1$iter,
  #      Lagrangian = res1$lagr,
  #      iact=res1$iact[1:res1$nact])   
}
EOD

pp_add_boot(<<EOB);
   pdl1 = PDL->pdlnew();
   pdl2 = PDL->pdlnew();
   pdl3 = PDL->pdlnew();
   pdl4 = PDL->pdlnew();
   pdl5 = PDL->pdlnew();
   sv_pdl1 = newSV(0);
   sv_pdl2 = newSV(0);
   sv_pdl3 = newSV(0);
   sv_pdl4 = newSV(0);
   sv_pdl5 = newSV(0);
   PDL->SetSV_PDL(sv_pdl1, pdl1);
   PDL->SetSV_PDL(sv_pdl2, pdl2);
   PDL->SetSV_PDL(sv_pdl3, pdl3);
   PDL->SetSV_PDL(sv_pdl4, pdl4);
   PDL->SetSV_PDL(sv_pdl5, pdl5);
EOB

pp_done();  # you will need this to finish pp processing

